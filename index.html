<!DOCTYPE html>
<head>
    <title>FZRTH</title>
    <style>
        :root { --bg: #000; --fg: #fb0; --hl: #d33; }
        body { background: var(--bg); color: var(--fg); font-family: monospace; margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .header { font-size: 24px; padding: 10px; border-bottom: 1px solid #fb0; text-align: left; background: #111;}
        .container { position: relative; flex: 1; display: flex; }
        #editor { background: transparent; color: transparent; caret-color: #fff; z-index: 2; resize: none; }
        #editor, #highlight { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 20px; font-size: 20px; line-height: 1.5;
            white-space: pre-wrap; word-wrap: break-word;
            box-sizing: border-box; border: none; outline: none; margin: 0;
            font-family: 'Courier New', monospace;
        }
        #highlight { z-index: 1; pointer-events: none; }
        .active { color: #fff; }
    </style>
</head>
<body>
    <div class="header">FZRTH</div>
    <div class="container">
        <div id="highlight"></div>
        <textarea id="editor" spellcheck="false">
300 bpm
: foo 600 0 slide ;
: bar 300 1000 irand ;
: baz 300 bar irand ;
: qux baz bar baz <100 200> - ;
: bzz t baz bar irand * sin <bar baz> 1000 - *; 
: brr t [10 <15 23>] 10 666 irand + * sin <24 65 24> 100 * * ;

[[bd bd] <bd hh>] 0.25 speed play
0 foo 4 on sine
(bar bar 100 + bar 200 +) 500 - sine
qux tri
bzz sqr
brr sine</textarea>
    </div>

    <template id="template">
       <script id="processor">

        const SUB = 'SUB', CYC = 'CYC', CHO = 'CHO', SEL = 'SEL', SPEED = 'SPEED';
        const MARKERS = [SUB, CYC, CHO, SEL, SPEED];

        const DICT = {
            'sine': (c) => compile(c, 'SINE'),
            'tri':  (c) => compile(c, 'TRI'),
            'saw':  (c) => compile(c, 'SAW'),
            'sqr':  (c) => compile(c, 'SQR'),
            'noise':(c) => compile(c, 'NOISE'),
            'play': (c) => compile(c, 'SMP'), 
            'speed': (c, t) => modify(c, t, SPEED),
            'bpm':  (c) => { if (c.stack.length > 0) c.bpm = resolve(c.stack.pop(), {beat:0}); },
            '[':    (c) => c.stack.push(SUB),
            ']':    (c) => closeGroup(c, SUB),
            '<':    (c) => c.stack.push(CYC),
            '>':    (c) => closeGroup(c, CYC),
            '(':    (c) => c.stack.push(CHO), 
            ')':    (c) => closeGroup(c, CHO),
            ':':    (c) => defineWord(c),
            'midi': (c) => { c.isMidi = true; },
            '+':    (c, t) => calc(c, t, (a, b) => a + b),
            '-':    (c, t) => calc(c, t, (a, b) => a - b),
            '*':    (c, t) => calc(c, t, (a, b) => a * b),
            '/':    (c, t) => calc(c, t, (a, b) => a / b),
            '%':    (c, t) => calc(c, t, (a, b) => a % b),
            'and':    (c, t) => calc(c, t, (a, b) => a & b),
            'or':    (c, t) => calc(c, t, (a, b) => a | b),
            'xor':    (c, t) => calc(c, t, (a, b) => a ^ b),
            'lshift':(c, t) => calc(c, t, (a, b) => a << b),
            'rshift':(c, t) => calc(c, t, (a, b) => a >> b),
            'shift': (c, t) => calc(c, t, (a, b) => b >= 0 ? a << b : a >> -b),
            'eq':   (c, t) => calc(c, t, (a, b) => a === b ? 1 : 0),
            'neq':  (c, t) => calc(c, t, (a, b) => a !== b ? 1 : 0),
            'lt':   (c, t) => calc(c, t, (a, b) => a < b ? 1 : 0),
            'gt':   (c, t) => calc(c, t, (a, b) => a > b ? 1 : 0),
            'lte':  (c, t) => calc(c, t, (a, b) => a <= b ? 1 : 0),
            'gte':  (c, t) => calc(c, t, (a, b) => a >= b ? 1 : 0),
            'pow':  (c, t) => calc(c, t, Math.pow),
            'min':  (c, t) => calc(c, t, Math.min),
            'max':  (c, t) => calc(c, t, Math.max),
            'sin':  (c, t) => calc(c, t, Math.sin),
            'cos':  (c, t) => calc(c, t, Math.cos),
            'tan':  (c, t) => calc(c, t, Math.tan),
            'abs':  (c, t) => calc(c, t, Math.abs),
            'sqrt': (c, t) => calc(c, t, Math.sqrt),
            'log':  (c, t) => calc(c, t, Math.log),
            'floor':(c, t) => calc(c, t, Math.floor),
            'ceil': (c, t) => calc(c, t, Math.ceil),
            'round':(c, t) => calc(c, t, Math.round),
            'pi':   (c, t) => c.stack.push({ val: Math.PI, ranges: [t] }),
            'rand': (c, t) => calc(c, t, Math.random, true),
            'irand':(c, t) => calc(c, t, (a, b) => Math.floor(a + Math.random() * (b - a)), true),
            'rrand':(c, t) => calc(c, t, (a, b) => a + Math.random() * (b - a), true),
            'beat': (c, t) => c.stack.push({ type: 'VAR', name: 'beat', ranges: [t] }),
            'time': (c, t) => c.stack.push({ type: 'VAR', name: 'time', ranges: [t] }),
            'tick': (c, t) => c.stack.push({ type: 'VAR', name: 'tick', ranges: [t] }),
            'slide': (c, t) => calc(c, t, function(a, b) { return a + (b - a) * (arguments[2] % 1); }),
            '?':    (c) => {
                if (c.stack.length < 3) return;
                const cond = c.stack.pop(); 
                const t = c.stack.pop();    
                const f = c.stack.pop();    
                const ranges = [f, t, cond].flatMap(x => x.ranges || [x]);
                c.stack.push({ type: SEL, cond, t, f, ranges });
            },
            'on': (c, tToken) => {
                if (c.stack.length < 3) return;
                const mod = c.stack.pop();
                const tBranch = c.stack.pop();
                const fBranch = c.stack.pop();
                const condNode = { 
                    type: 'OP', 
                    fn: (m, _, b) => Math.floor(b) % m === 0 ? 1 : 0, 
                    args: [mod], 
                    ranges: [tToken] 
                };
                const ranges = [fBranch, tBranch, mod].flatMap(x => x.ranges || [x]);
                c.stack.push({ type: SEL, cond: condNode, t: tBranch, f: fBranch, ranges });
            },
            'dup':  (c) => { if (c.stack.length) c.stack.push(c.stack[c.stack.length-1]); },
            'pop': (c) => { if (c.stack.length) c.stack.pop(); },
            'swap': (c) => { if (c.stack.length > 1) { const a = c.stack.pop(), b = c.stack.pop(); c.stack.push(a, b); } },
            'pick': (c) => { 
                    const n = resolve(c.stack.pop(), {beat:0}); 
                    if (c.stack.length > n) c.stack.push(c.stack[c.stack.length - 1 - n]); 
            },
        };

        const SHORTHANDS = {
            'b':  'beat',
            's':  'time',
            't':  'tick',
            'rs': 'rshift',
            'ls': 'lshift',
            'sh': 'shift'
        };

        Object.keys(SHORTHANDS).forEach(k => {
            if (DICT[SHORTHANDS[k]]) DICT[k] = DICT[SHORTHANDS[k]];
        });

        const modify = (c, tToken, type) => {
            if (c.stack.length < 2) return;
            const amount = c.stack.pop();
            const data = c.stack.pop();
            if (MARKERS.includes(data) || MARKERS.includes(amount)) return;
            const ranges = [tToken, ...(amount.ranges||[amount]), ...(data.ranges||[data])];
            c.stack.push({ type, amount, data, ranges });
        };

        const compile = (c, type) => {
            if (c.isEval) {
                if (c.stack.length) {
                    const val = c.stack.pop();
                    const text = `${format(val)} ${type.toLowerCase()}`;
                    c.stack.push({ type: 'FMT', val: text });
                }
            } else {
                createSound(c, type);
            }
        };

        const format = (v) => {
            if (v === undefined) return '';
            if (v.type === 'FMT') return v.val;
            if (v.type === 'STR') return v.name + (v.idx ? ':'+v.idx : '');
            if (v.type === 'OP' || v.type === 'VAR') return parseFloat(resolve(v, {beat:0, time:0, tick:0}).toFixed(3));
            if (v.val !== undefined) return parseFloat(v.val.toFixed(3));
            if (v.type === SEL) return `[${format(v.f)}] [${format(v.t)}] ${format(v.cond)} ?`;
            if (v.type === SPEED) return `[${format(v.data)}] ${format(v.amount)} speed`;
            if (v.data) {
                const m = {[SUB]:'[]', [CYC]:'<>', [CHO]:'()'}, w = m[v.type]||'[]';
                return w[0] + v.data.map(format).join(' ') + w[1];
            }
            return '?';
        };

        const calc = (c, opToken, fn, isRand = false) => {
            if (c.stack.length < fn.length) return;
            const args = [];
            for(let i=0; i<fn.length; i++) args.unshift(c.stack.pop());
            const getR = (x) => x.ranges || [x];
            const deep = (a, b) => {
                if (b !== undefined) {
                    if (a.data) return { ...a, data: a.data.map(i => deep(i, b)) };
                    if (b.data) return { ...b, data: b.data.map(i => deep(a, i)) };
                    return { type: 'OP', fn, args: [a, b], ranges: [opToken, ...getR(a), ...getR(b)], isRand };
                }
                if (a.data) return { ...a, data: a.data.map(i => deep(i)) };
                return { type: 'OP', fn, args: [a], ranges: [opToken, ...getR(a)], isRand };
            };
            c.stack.push(deep(args[0], args[1]));
        };

        const resolve = (node, env) => {
            if (!node) return 0;
            if (node.val !== undefined) return node.val;
            if (node.type === 'STR') return node;
            if (node.type === 'OP') {
                if (node.args.length === 0) return node.fn();
                const a = resolve(node.args[0], env);
                const b = node.args[1] ? resolve(node.args[1], env) : undefined;
                const sa = (typeof a === 'number') ? a : 0;
                const sb = (typeof b === 'number') ? b : 0;
                return node.fn(sa, sb, env.beat); 
            }
            if (node.type === 'VAR') return env[node.name] || 0;
            return 0;
        }

        const SOUNDS = {
            'SINE': (p) => Math.sin(p * 2 * Math.PI),
            'TRI':  (p) => Math.abs((p % 1) * 4 - 2) - 1,
            'SAW':  (p) => (p % 1) * 2 - 1,
            'SQR':  (p) => (p % 1) < 0.5 ? 0.5 : -0.5,
            'NOISE':(p) => Math.random() * 2 - 1,
            'SMP': (p, buf) => { 
                if (!buf) return 0;
                const idx = Math.floor(p * buf.sr);
                return (idx >= 0 && idx < buf.len) ? buf.data[idx] : 0;
            }
        };

        function defineWord(c) {
            const nameToken = c.tokens[c.pos++];
            const name = nameToken.val;
            const body = [];
            while (c.pos < c.tokens.length) {
                const t = c.tokens[c.pos++];
                if (t.val === ';') break;
                body.push(t);
            }
            c.dict[name] = (ctx, caller) => { 
                const savedTokens = ctx.tokens, savedPos = ctx.pos;
                ctx.tokens = body; ctx.pos = 0;
                const stackStart = ctx.stack.length;
                run(ctx);
                if (caller) {
                    for(let i = stackStart; i < ctx.stack.length; i++) {
                        const node = ctx.stack[i];
                        if (!node.ranges) node.ranges = [node];
                        node.ranges.push(caller);
                    }
                }
                ctx.tokens = savedTokens; ctx.pos = savedPos;
            };
        }

        function run(c) {
            while (c.pos < c.tokens.length) {
                const t = c.tokens[c.pos++];
                const num = parseFloat(t.val);
                if (!isNaN(num) && !t.val.includes(':')) c.stack.push({ val: num, s: t.s, e: t.e });
                else if (c.dict[t.val]) c.dict[t.val](c, t);
                else {
                    const raw = t.val;
                    const parts = raw.split(':');
                    const name = parts[0];
                    const idx = parts.length > 1 ? parseInt(parts[1]) : 0;
                    c.stack.push({ type: 'STR', name, idx, s: t.s, e: t.e });
                }
            }
        }

        const midiToFreq = (n) => n === 0 ? 0 : 440 * Math.pow(2, (n - 69) / 12);

        function createSound(c, type) {
            if (c.stack.length === 0) return;
            const s = c.stack.splice(0);
            const valid = s.filter(x => typeof x === 'object');
            if (valid.length === 0) return;

            let pattern = valid.length > 1 ? { type: SUB, data: valid } : valid[0];
            
            if (c.isMidi) {
                const convert = (item) => {
                    if (item.val !== undefined) { item.val = midiToFreq(item.val); return item; }
                    if (item.data) { item.data = item.data.map(convert); return item; }
                    return item;
                }
                pattern = convert(pattern);
                c.isMidi = false; 
            }
            c.newSounds.push(new Sound(pattern, type));
        }

        function closeGroup(c, marker) {
            const tmp = [];
            while (c.stack.length > 0) {
                const item = c.stack.pop();
                if (item === marker) {
                    const data = tmp.filter(x => !MARKERS.includes(x)).reverse();
                    const ranges = data.flatMap(x => x.ranges||[x]);
                    c.stack.push({ type: marker, data, ranges, idx: 0 });
                    return;
                }
                tmp.push(item);
            }
            while (tmp.length > 0) c.stack.push(tmp.pop());
        }

        class Sound {
            constructor(pattern, waveType) {
                this.pattern = pattern;
                this.waveType = waveType;
                this.render = SOUNDS[waveType];
                this.signature = JSON.stringify(pattern, (k, v) => (k==='s'||k==='e'||k==='ranges') ? undefined : v) + ':' + waveType;
                this.currNodes = [];
                this.currRanges = []; 
                this.endTime = -1;
                this.env = { beat: 0, time: 0, tick: 0 }; 
                this.iter = this.makeIterator();
                this.voices = []; 
                this.nextPattern = null;
            }

            *makeIterator() { 
                while (true) {
                    if (this.nextPattern) {
                        this.pattern = this.nextPattern;
                        this.nextPattern = null;
                    }
                    yield* this.visit(this.pattern, 1.0); 
                }
            }

            instantiate(node) {
                if (!node) return node;
                if (node.isRand) return { val: resolve(node, {beat:0, time:0, tick:0}), ranges: node.ranges };
                if (node.args) return { ...node, args: node.args.map(n => this.instantiate(n)) };
                return node;
            }

            *visit(node, duration) {
                const ranges = node.ranges || (node.s !== undefined ? [node] : []);
                
                if (node.val !== undefined || node.type === 'OP' || node.type === 'VAR' || node.type === 'STR') {
                    const activeNode = this.instantiate(node);
                    yield { nodes: [activeNode], ranges: ranges, dur: duration };
                }
                else if (node?.type === CHO) {
                    const data = node.data.flatMap(n => this.collect(n));
                    const activeNodes = data.map(n => this.instantiate(n));
                    yield { 
                        nodes: activeNodes, 
                        ranges: data.flatMap(d => d.ranges || [d]), 
                        dur: duration 
                    };
                }
                else if (node?.type === SUB) {
                    if (node.data.length === 0) {
                        yield { nodes: [], ranges: [], dur: duration };
                    } else {
                        const step = duration / node.data.length;
                        for (const item of node.data) yield* this.visit(item, step);
                    }
                } 
                else if (node?.type === CYC) {
                    if (node.data.length > 0) {
                        yield* this.visit(node.data[node.idx++ % node.data.length], duration);
                    } else {
                        yield { nodes: [], ranges: [], dur: duration };
                    }
                }
                else if (node?.type === SEL) {
                    const condVal = resolve(node.cond, this.env);
                    const branch = condVal !== 0 ? node.t : node.f;
                    yield* this.visit(branch, duration);
                }
                else if (node?.type === SPEED) {
                    let valNode = node.amount;
                    if (valNode.type === CYC) {
                         if (valNode.data.length > 0) {
                            valNode = valNode.data[valNode.idx++ % valNode.data.length];
                         } else return;
                    }
                    const amt = resolve(valNode, this.env);
                    let factor = amt;
                    if (amt < 0) factor = 1 / Math.abs(amt); 
                    if (factor === 0) factor = 1;
                    yield* this.visit(node.data, duration / factor);
                }
            }

            collect(node) {
                if (node.val !== undefined || node.type === 'OP' || node.type === 'VAR' || node.type === 'STR') return [node];
                if (node?.type === CHO || node?.type === SUB) return node.data.flatMap(n => this.collect(n));
                if (node?.type === CYC) return this.collect(node.data[node.idx % node.data.length]);
                if (node?.type === SEL) return [...this.collect(node.t), ...this.collect(node.f)];
                if (node?.type === SPEED) return this.collect(node.data);
                return [];
            }
        }

        class ForthProcessor extends AudioWorkletProcessor {
            constructor() {
                super();
                this.sounds = [];
                this.samples = {};
                this.requested = new Set();
                this.pending = null; 
                this.bpm = 120;
                this.beats = 0;
                this.time = 0;
                this.tick = 0;
                const refRate = 44100;
                this.kFreq = 0.05 * (refRate / sampleRate); 
                this.kAmp = 0.05 * (refRate / sampleRate);  
                this.port.onmessage = (e) => this.handleMsg(e.data);
                this.env = { beat: 0, time: 0, tick: 0 };
            }

            handleMsg(msg) {
                if (msg.type === 'setSample') {
                    this.samples[msg.key] = { data: msg.buffer, sr: msg.sr, len: msg.buffer.length };
                    return;
                }

                const isEval = msg.type === 'eval';
                const text = isEval ? msg.code : msg;
                const tokens = [];
                const regex = /#.*|[^\s\[\]<>() ;]+|[\[\]<>() ;]/g;
                let m;
                while ((m = regex.exec(text)) !== null) {
                    if (!m[0].trim()) continue;
                    if (m[0].startsWith('#')) continue;
                    tokens.push({ val: m[0], s: m.index, e: m.index + m[0].length });
                }

                const ctx = {
                    tokens, pos: 0, stack: [], newSounds: [],
                    dict: Object.assign({}, DICT), bpm: this.bpm,
                    isEval, results: []
                };

                try { run(ctx); } catch(e) {} 

                if (isEval) {
                    const result = ctx.stack.map(format).join(' ');
                    this.port.postMessage({ type: 'result', code: result });
                    return;
                }

                this.pending = { sounds: ctx.newSounds, bpm: ctx.bpm };

                if (ctx.newSounds.length > 0) {
                    const traverse = (n) => {
                        if (n.type === 'STR') {
                            const key = n.name + ':' + n.idx;
                            if (!this.samples[key] && !this.requested.has(key)) {
                                this.requested.add(key);
                                this.port.postMessage({ type: 'reqSample', name: n.name, idx: n.idx });
                            }
                        } else if (n.data) {
                             if (Array.isArray(n.data)) n.data.forEach(traverse);
                             else traverse(n.data);
                        }
                        else if (n.t) { traverse(n.t); traverse(n.f); }
                    };
                    ctx.newSounds.forEach(s => {
                        if(s.waveType === 'SMP') traverse(s.pattern);
                    });
                }
            }

            process(inputs, outputs) {
                const output = outputs[0];
                if (!output || !output.length) return true;
                
                const delta = 1 / sampleRate;
                const numChannels = output.length;
                const bufferLen = output[0].length;
                const durationPerSample = (this.bpm / 60) * delta;
                
                if (this.pending) {
                    const nextSounds = this.pending.sounds;
                    const claimed = new Set();
                    
                    nextSounds.forEach(newS => {
                        const match = this.sounds.find(oldS => 
                            oldS.waveType === newS.waveType && !claimed.has(oldS)
                        );
                        if (match) {
                            claimed.add(match);
                            match.nextPattern = newS.pattern;
                            match.signature = newS.signature;
                        } else {
                            this.sounds.push(newS);
                        }
                    });
                    
                    this.sounds = this.sounds.filter(s => claimed.has(s) || nextSounds.includes(s));
                    this.bpm = this.pending.bpm;
                    this.pending = null;
                }

                const activeRanges = [];
                
                for (let sIdx = 0; sIdx < this.sounds.length; sIdx++) {
                    const sound = this.sounds[sIdx];
                    let localBeat = this.beats;
                    let localTime = this.time;
                    let localTick = this.tick;
                    
                    if (sound.endTime < 0) sound.endTime = Math.floor(localBeat);

                    if (sound.currRanges && sound.currRanges.length > 0) {
                         activeRanges.push(...sound.currRanges);
                    }

                    let frame = 0;
                    while (frame < bufferLen) {
                        
                        while (localBeat >= sound.endTime) {
                            const result = sound.iter.next();
                            if (result.done) {
                                sound.endTime = Infinity;
                                break;
                            }
                            sound.currNodes = result.value.nodes;
                            sound.currRanges = result.value.ranges || [];
                            sound.endTime += result.value.dur; 
                            
                            if (frame === 0 && sound.currRanges.length > 0) {
                                activeRanges.push(...sound.currRanges);
                            }

                            if (sound.waveType === 'SMP') {
                                for (let v = 0; v < sound.voices.length; v++) {
                                    sound.voices[v].p = 0;
                                    sound.voices[v].a = 1;
                                }
                            }
                        }

                        if (sound.endTime === Infinity) break;

                        const samplesUntilEvent = Math.ceil((sound.endTime - localBeat) / durationPerSample);
                        const samplesRemaining = bufferLen - frame;
                        let count = samplesUntilEvent < samplesRemaining ? samplesUntilEvent : samplesRemaining;
                        if (count < 1) count = 1;

                        while(sound.voices.length < sound.currNodes.length) {
                            const initAmp = sound.waveType === 'SMP' ? 1 : 0;
                            sound.voices.push({ f: 0, a: initAmp, p: 0 });
                        }

                        const isSmp = sound.waveType === 'SMP';
                        const voices = sound.voices;
                        const nodes = sound.currNodes;
                        const renderFn = sound.render;
                        
                        for (let k = 0; k < count; k++) {
                            const i = frame + k;
                            this.env.beat = localBeat;
                            this.env.time = localTime;
                            this.env.tick = localTick;
                            
                            let signal = 0;

                            for (let vIdx = 0; vIdx < nodes.length; vIdx++) {
                                const voice = voices[vIdx];
                                const resolved = resolve(nodes[vIdx], this.env);

                                if (isSmp) {
                                    if (resolved && resolved.type === 'STR') {
                                        const key = resolved.name + ':' + resolved.idx;
                                        const buf = this.samples[key];
                                        if (buf && voice.a > 0) {
                                            signal += renderFn(voice.p, buf);
                                            voice.p += delta; 
                                        }
                                    }
                                } else {
                                    const targetFreq = (typeof resolved === 'number') ? resolved : 0;
                                    if (targetFreq > 0) {
                                        voice.f += (targetFreq - voice.f) * this.kFreq;
                                        voice.a += (1.0 - voice.a) * this.kAmp;
                                    } else {
                                        voice.a += (0.0 - voice.a) * this.kAmp;
                                    }
                                    if (voice.a > 0.001) {
                                        voice.p += (voice.f * delta);
                                        signal += renderFn(voice.p) * voice.a;
                                    }
                                }
                            }

                            const outSig = signal * 0.15;
                            for (let c = 0; c < numChannels; c++) {
                                output[c][i] += outSig;
                            }

                            localBeat += durationPerSample;
                            localTime += delta;
                            localTick++;
                        }
                        
                        frame += count;
                    }
                }

                this.beats += bufferLen * durationPerSample;
                this.time += bufferLen * delta;
                this.tick += bufferLen;
                
                if (activeRanges.length > 0) this.port.postMessage(activeRanges);
                return true;
            }
        }
        registerProcessor('forth-proc', ForthProcessor);
        </script>
    </template>

<script>
    const ed = document.getElementById('editor');
    const hl = document.getElementById('highlight');
    let ctx, node;

    const LOADER = {
        map: null,
        loadingMap: null,
        base: 'https://raw.githubusercontent.com/tidalcycles/dirt-samples/master/',
        async load(name, idx, port) {
            if (!this.map) {
                if (!this.loadingMap) {
                    this.loadingMap = fetch(this.base+'strudel.json').then(r=>r.json());
                }
                try { this.map = await this.loadingMap; } catch(e){ return; }
            }
            const k = `${name}:${idx}`;
            let entry = this.map[name];
            if (!entry) return;
            
            let path = '';
            if (Array.isArray(entry)) path = entry[idx]||entry[0];
            else if (typeof entry === 'object') {
                const all = Object.values(entry).flat();
                path = all[idx]||all[0];
            }
            if (!path) return;
            
            try {
                const ab = await (await fetch(this.base + path)).arrayBuffer();
                const aud = await ctx.decodeAudioData(ab);
                port.postMessage({type:'setSample', key:k, buffer:aud.getChannelData(0), sr:aud.sampleRate});
            } catch(e) { console.log(e); }
        }
    };

    ed.addEventListener('keydown', e => {
        if (e.shiftKey && e.key === 'Enter') { 
            e.preventDefault(); 
            let s = ed.selectionStart, eIdx = ed.selectionEnd;
            if (s === eIdx) {
                s = ed.value.lastIndexOf('\n', s - 1) + 1;
                eIdx = ed.value.indexOf('\n', s);
                if (eIdx === -1) eIdx = ed.value.length;
            }
            const raw = ed.value.substring(s, eIdx);
            if (raw.trim() && node) {
                ed._evalRange = { s, e: eIdx };
                node.port.postMessage({ type: 'eval', code: raw });
            }
        }
    });

    function renderHighlights(ranges) {
        if (!Array.isArray(ranges)) return;
        const text = ed.value;
        let html = '';
        let lastPos = 0;
        
        const unique = [];
        const map = new Set();
        ranges.forEach(r => {
            const k = r.s + ":" + r.e;
            if(!map.has(k) && r.e > 0) { map.add(k); unique.push(r); }
        });
        unique.sort((a,b) => a.s - b.s);

        unique.forEach(range => {
            html += escapeHtml(text.substring(lastPos, range.s));
            html += `<span class="active">${escapeHtml(text.substring(range.s, range.e))}</span>`;
            lastPos = range.e;
        });
        html += escapeHtml(text.substring(lastPos));
        
        hl.innerHTML = html.replace(/\n/g, '<br/>') + (text.endsWith('\n') ? '<br/>&nbsp;' : '');
    }

    function escapeHtml(str) {
        return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    ed.addEventListener('scroll', () => hl.scrollTop = ed.scrollTop);

    ed.addEventListener('input', () => {
        hl.innerHTML = escapeHtml(ed.value).replace(/\n/g, '<br/>');
        if(node) node.port.postMessage(ed.value); 
    });

    async function init() {
        if (ctx) { ctx.resume(); return; }
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        
        const template = document.getElementById('template');
        const code = template.content.getElementById('processor').textContent;
        const blob = new Blob([code], {type: 'application/javascript'});
        try {
            await ctx.audioWorklet.addModule(URL.createObjectURL(blob));
            node = new AudioWorkletNode(ctx, 'forth-proc');
            node.connect(ctx.destination);
            
            node.port.onmessage = (e) => {
                if (e.data.type === 'result') {
                    const r = ed._evalRange;
                    if (r) {
                        ed.setRangeText(e.data.code, r.s, r.e, 'end');
                        node.port.postMessage(ed.value);
                        hl.innerHTML = escapeHtml(ed.value).replace(/\n/g, '<br/>');
                        ed._evalRange = null;
                    }
                } else if (e.data.type === 'reqSample') {
                    LOADER.load(e.data.name, e.data.idx, node.port);
                } else {
                    renderHighlights(e.data);
                }
            };
            node.port.postMessage(ed.value);
        } catch(e) {
            console.error("AudioWorklet Error:", e);
        }
    }

    document.addEventListener('click', init, {once:true});
    hl.innerHTML = escapeHtml(ed.value).replace(/\n/g, '<br/>');
</script>
</body>
</html>