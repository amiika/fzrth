<!DOCTYPE html>
<head>
    <title>FZRTH</title>
    <style>
        :root { --bg: #000; --fg: #fb0; --hl: #d33; }
        body { background: var(--bg); color: var(--fg); font-family: monospace; margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .header { font-size: 24px; padding: 10px; border-bottom: 1px solid #fb0; text-align: left; background: #111;}
        .container { position: relative; flex: 1; display: flex; }
        #editor { background: transparent; color: transparent; caret-color: #fff; z-index: 2; resize: none; }
        #editor, #highlight { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 20px; font-size: 20px; line-height: 1.5;
            white-space: pre-wrap; word-wrap: break-word;
            box-sizing: border-box; border: none; outline: none; margin: 0;
            font-family: 'Courier New', monospace;
        }
        #highlight { z-index: 1; pointer-events: none; }
        .active { color: #fff; }
    </style>
</head>
<body>
    <div class="header">FZRTH</div>
    <div class="container">
        <div id="highlight"></div>
        <textarea id="editor" spellcheck="false">
: foo 100 200 irand ;
: bar 100 foo irand ;

[100 150 foo bar] [foo foo foo] saw

# Random cutoff filter effect
t [10 <15 23>] 10 666 irand + * sin <24 65 24> 100 * * sine</textarea>
    </div>

    <template id="template">
        <script id="processor">

        const SUB = 'SUB';
        const CYC = 'CYC';
        const CHO = 'CHO';

        const DICT = {
            'sine': (c) => compile(c, 'SINE'),
            'tri':  (c) => compile(c, 'TRI'),
            'saw':  (c) => compile(c, 'SAW'),
            'sqr':  (c) => compile(c, 'SQR'),
            'bpm':  (c) => { if (c.stack.length > 0) c.bpm = resolve(c.stack.pop(), {beat:0}); },
            '[':    (c) => c.stack.push(SUB),
            ']':    (c) => closeGroup(c, SUB),
            '<':    (c) => c.stack.push(CYC),
            '>':    (c) => closeGroup(c, CYC),
            '(':    (c) => c.stack.push(CHO), 
            ')':    (c) => closeGroup(c, CHO),
            ':':    (c) => defineWord(c),
            'midi': (c) => { c.isMidi = true; },
            '+':    (c, t) => calc(c, t, (a, b) => a + b),
            '-':    (c, t) => calc(c, t, (a, b) => a - b),
            '*':    (c, t) => calc(c, t, (a, b) => a * b),
            '/':    (c, t) => calc(c, t, (a, b) => a / b),
            '%':    (c, t) => calc(c, t, (a, b) => a % b),
            'pow':  (c, t) => calc(c, t, Math.pow),
            'min':  (c, t) => calc(c, t, Math.min),
            'max':  (c, t) => calc(c, t, Math.max),
            'sin':  (c, t) => calc(c, t, Math.sin),
            'cos':  (c, t) => calc(c, t, Math.cos),
            'tan':  (c, t) => calc(c, t, Math.tan),
            'abs':  (c, t) => calc(c, t, Math.abs),
            'sqrt': (c, t) => calc(c, t, Math.sqrt),
            'log':  (c, t) => calc(c, t, Math.log),
            'pi':   (c, t) => c.stack.push({ val: Math.PI, ranges: [t] }),
            'rand': (c, t) => calc(c, t, Math.random, true),
            'irand':(c, t) => calc(c, t, (a, b) => Math.floor(a + Math.random() * (b - a)), true),
            'rrand':(c, t) => calc(c, t, (a, b) => a + Math.random() * (b - a), true),
            'beat': (c, t) => c.stack.push({ type: 'VAR', name: 'beat', ranges: [t] }),
            't':    (c, t) => c.stack.push({ type: 'VAR', name: 'time', ranges: [t] }),
            'tick': (c, t) => c.stack.push({ type: 'VAR', name: 'tick', ranges: [t] }),
        };

        const compile = (c, type) => {
            if (c.isEval) {
                if (c.stack.length) {
                    const val = c.stack.pop();
                    const text = `${format(val)} ${type.toLowerCase()}`;
                    c.stack.push({ type: 'FMT', val: text });
                }
            } else {
                createSound(c, type);
            }
        };

        const format = (v) => {
            if (v === undefined) return '';
            if (v.type === 'FMT') return v.val;
            if (v.type === 'OP' || v.type === 'VAR') return parseFloat(resolve(v, {beat:0, time:0, tick:0}).toFixed(3));
            if (v.val !== undefined) return parseFloat(v.val.toFixed(3));
            if (v.data) {
                const m = {[SUB]:'[]', [CYC]:'<>', [CHO]:'()'}, w = m[v.type]||'[]';
                return w[0] + v.data.map(format).join(' ') + w[1];
            }
            return '?';
        };

        const calc = (c, opToken, fn, isRand = false) => {
            if (c.stack.length < fn.length) return;
            if (fn.length === 0) {
                c.stack.push({ type: 'OP', fn, args: [], ranges: [opToken], isRand });
                return;
            }
            const args = [];
            for(let i=0; i<fn.length; i++) args.unshift(c.stack.pop());
            const getR = (x) => x.ranges || [x];

            const deep = (a, b) => {
                if (b !== undefined) {
                    if (a.data) return { ...a, data: a.data.map(i => deep(i, b)) };
                    if (b.data) return { ...b, data: b.data.map(i => deep(a, i)) };
                    return { type: 'OP', fn, args: [a, b], ranges: [opToken, ...getR(a), ...getR(b)], isRand };
                }
                if (a.data) return { ...a, data: a.data.map(i => deep(i)) };
                return { type: 'OP', fn, args: [a], ranges: [opToken, ...getR(a)], isRand };
            };
            c.stack.push(deep(args[0], args[1]));
        };

        const resolve = (node, env) => {
            if (!node) return 0;
            if (node.val !== undefined) return node.val;
            if (node.type === 'OP') {
                if (node.args.length === 0) return node.fn();
                const a = resolve(node.args[0], env);
                const b = node.args[1] ? resolve(node.args[1], env) : undefined;
                return node.fn(a, b);
            }
            if (node.type === 'VAR') return env[node.name] || 0;
            return 0;
        }

        const WAVES = {
            'SINE': (p) => Math.sin(p * 2 * Math.PI),
            'TRI':  (p) => Math.abs((p % 1) * 4 - 2) - 1,
            'SAW':  (p) => (p % 1) * 2 - 1,
            'SQR':  (p) => (p % 1) < 0.5 ? 0.5 : -0.5
        };

        function defineWord(c) {
            const nameToken = c.tokens[c.pos++];
            const name = nameToken.val;
            const body = [];
            while (c.pos < c.tokens.length) {
                const t = c.tokens[c.pos++];
                if (t.val === ';') break;
                body.push(t);
            }
            c.dict[name] = (ctx, caller) => { 
                const savedTokens = ctx.tokens, savedPos = ctx.pos;
                ctx.tokens = body; ctx.pos = 0;
                const stackStart = ctx.stack.length;
                run(ctx);
                if (caller) {
                    for(let i = stackStart; i < ctx.stack.length; i++) {
                        const node = ctx.stack[i];
                        if (!node.ranges) node.ranges = [node];
                        node.ranges.push(caller);
                    }
                }
                ctx.tokens = savedTokens; ctx.pos = savedPos;
            };
        }

        function run(c) {
            while (c.pos < c.tokens.length) {
                const t = c.tokens[c.pos++];
                const num = parseFloat(t.val);
                if (!isNaN(num)) c.stack.push({ val: num, s: t.s, e: t.e });
                else if (c.dict[t.val]) c.dict[t.val](c, t);
            }
        }

        const midiToFreq = (n) => n === 0 ? 0 : 440 * Math.pow(2, (n - 69) / 12);

        function createSound(c, type) {
            if (c.stack.length === 0) return;
            if (c.isMidi) {
                const convert = (item) => {
                    if (item.val !== undefined) { item.val = midiToFreq(item.val); return item; }
                    if (item.data) { item.data = item.data.map(convert); return item; }
                    return item;
                }
                c.stack = c.stack.map(convert);
                c.isMidi = false; 
            }
            let pattern = c.stack.length > 1 ? { type: SUB, data: [...c.stack] } : c.stack[0];
            c.newSounds.push(new Sound(pattern, type));
            c.stack.length = 0;
        }

        function closeGroup(c, marker) {
            const tmp = [];
            while (c.stack.length > 0) {
                const item = c.stack.pop();
                if (item === marker) {
                    const ranges = tmp.flatMap(x => x.ranges||[x]);
                    c.stack.push({ type: marker, data: tmp.reverse(), ranges, idx: 0 });
                    return;
                }
                tmp.push(item);
            }
        }

        class Sound {
            constructor(pattern, waveType) {
                this.pattern = pattern;
                this.waveType = waveType;
                this.render = WAVES[waveType];
                this.signature = JSON.stringify(pattern, (k, v) => (k==='s'||k==='e'||k==='idx'||k==='ranges') ? undefined : v) + ':' + waveType;
                this.phase = 0;
                this.currNodes = [];
                this.currRanges = []; 
                this.endTime = -1;
                this.iter = this.makeIterator();
            }

            *makeIterator() { while (true) yield* this.visit(this.pattern, 1.0); }

            instantiate(node) {
                if (!node) return node;
                if (node.isRand) return { val: resolve(node, {beat:0, time:0, tick:0}), ranges: node.ranges };
                if (node.args) return { ...node, args: node.args.map(n => this.instantiate(n)) };
                return node;
            }

            *visit(node, duration) {
                const ranges = node.ranges || (node.val !== undefined ? [node] : []);
                
                if (node.val !== undefined || node.type === 'OP' || node.type === 'VAR') {
                    const activeNode = this.instantiate(node);
                    yield { nodes: [activeNode], ranges: ranges, dur: duration };
                }
                else if (node?.type === CHO) {
                    const data = node.data.flatMap(n => this.collect(n));
                    const activeNodes = data.map(n => this.instantiate(n));
                    yield { 
                        nodes: activeNodes, 
                        ranges: data.flatMap(d => d.ranges || [d]), 
                        dur: duration 
                    };
                }
                else if (node?.type === SUB) {
                    const step = duration / node.data.length;
                    for (const item of node.data) yield* this.visit(item, step);
                } 
                else if (node?.type === CYC) {
                    yield* this.visit(node.data[node.idx++ % node.data.length], duration);
                }
            }

            collect(node) {
                if (node.val !== undefined || node.type === 'OP' || node.type === 'VAR') return [node];
                if (node?.type === CHO || node?.type === SUB) return node.data.flatMap(n => this.collect(n));
                if (node?.type === CYC) return this.collect(node.data[node.idx % node.data.length]);
                return [];
            }
        }

        class ForthProcessor extends AudioWorkletProcessor {
            constructor() {
                super();
                this.sounds = [];
                this.pending = null; 
                this.bpm = 120;
                this.beats = 0;
                this.time = 0;
                this.tick = 0;
                this.port.onmessage = (e) => this.handleMsg(e.data);
            }

            handleMsg(msg) {
                const isEval = msg.type === 'eval';
                const text = isEval ? msg.code : msg;
                const tokens = [];
                const regex = /#.*|[^\s\[\]<>() :;]+|[\[\]<>() :;]/g;
                let m;
                while ((m = regex.exec(text)) !== null) {
                    if (!m[0].trim()) continue;
                    if (m[0].startsWith('#')) continue;
                    tokens.push({ val: m[0], s: m.index, e: m.index + m[0].length });
                }

                const ctx = {
                    tokens, pos: 0, stack: [], newSounds: [],
                    dict: Object.assign({}, DICT), bpm: this.bpm,
                    isEval, results: []
                };

                try { run(ctx); } catch(e) {} 

                if (isEval) {
                    const result = ctx.stack.map(format).join(' ');
                    this.port.postMessage({ type: 'result', code: result });
                    return;
                }

                if (ctx.stack.length === 0) {
                    this.pending = { sounds: ctx.newSounds, bpm: ctx.bpm };
                }
            }

            process(inputs, outputs) {
                const output = outputs[0][0];
                if (!output) return true;
                const delta = 1 / sampleRate;
                const duration = (this.bpm / 60) * delta;

                if (this.pending) {
                    const nextSounds = this.pending.sounds;
                    const claimed = new Set();
                    nextSounds.forEach(newS => {
                        const match = this.sounds.find(oldS => 
                            oldS.signature === newS.signature && !claimed.has(oldS)
                        );
                        if (match) {
                            claimed.add(match);
                            newS.phase = match.phase;
                        }
                    });
                    this.sounds = nextSounds;
                    this.bpm = this.pending.bpm;
                    this.pending = null;
                }

                let activeRanges = [];
                const env = { beat: this.beats, time: this.time, tick: this.tick };

                for (let i = 0; i < output.length; i++) {
                    this.beats += duration;
                    this.time += delta;
                    this.tick++;
                    
                    env.beat = this.beats; 
                    env.time = this.time; 
                    env.tick = this.tick;

                    let signal = 0;
                    this.sounds.forEach(v => {
                        if (v.endTime < 0) v.endTime = Math.floor(this.beats);
                        while (this.beats >= v.endTime) {
                            const result = v.iter.next();
                            v.currNodes = result.value.nodes;
                            v.currRanges = result.value.ranges || [];
                            v.endTime += result.value.dur; 
                        }
                        if (i === 0 && v.currRanges.length > 0) activeRanges.push(...v.currRanges);
                        v.currNodes.forEach(node => {
                            const f = resolve(node, env);
                            if (f > 0) {
                                v.phase += (f * delta);
                                signal += v.render(v.phase);
                            }
                        });
                    });
                    output[i] = signal * 0.15;
                }
                if (activeRanges.length > 0) this.port.postMessage(activeRanges);
                return true;
            }
        }
        registerProcessor('forth-proc', ForthProcessor);
        </script>
    </template>

<script>
    const ed = document.getElementById('editor');
    const hl = document.getElementById('highlight');
    let ctx, node;

    ed.addEventListener('keydown', e => {
        if (e.shiftKey && e.key === 'Enter') { 
            e.preventDefault(); 
            let s = ed.selectionStart, eIdx = ed.selectionEnd;
            if (s === eIdx) {
                s = ed.value.lastIndexOf('\n', s - 1) + 1;
                eIdx = ed.value.indexOf('\n', s);
                if (eIdx === -1) eIdx = ed.value.length;
            }
            const raw = ed.value.substring(s, eIdx);
            if (raw.trim() && node) {
                ed._evalRange = { s, e: eIdx };
                node.port.postMessage({ type: 'eval', code: raw });
            }
        }
    });

    function renderHighlights(ranges) {
        if (!Array.isArray(ranges)) return;
        const text = ed.value;
        let html = '';
        let lastPos = 0;
        
        const unique = [];
        const map = new Set();
        ranges.forEach(r => {
            const k = r.s + ":" + r.e;
            if(!map.has(k) && r.e > 0) { map.add(k); unique.push(r); }
        });
        unique.sort((a,b) => a.s - b.s);

        unique.forEach(range => {
            html += escapeHtml(text.substring(lastPos, range.s));
            html += `<span class="active">${escapeHtml(text.substring(range.s, range.e))}</span>`;
            lastPos = range.e;
        });
        html += escapeHtml(text.substring(lastPos));
        
        hl.innerHTML = html.replace(/\n/g, '<br/>') + (text.endsWith('\n') ? '<br/>&nbsp;' : '');
    }

    function escapeHtml(str) {
        return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    ed.addEventListener('scroll', () => hl.scrollTop = ed.scrollTop);

    ed.addEventListener('input', () => {
        hl.innerHTML = escapeHtml(ed.value).replace(/\n/g, '<br/>');
        if(node) node.port.postMessage(ed.value); 
    });

    async function init() {
        if (ctx) { ctx.resume(); return; }
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        
        const template = document.getElementById('template');
        const code = template.content.getElementById('processor').textContent;
        const blob = new Blob([code], {type: 'application/javascript'});
        try {
            await ctx.audioWorklet.addModule(URL.createObjectURL(blob));
            node = new AudioWorkletNode(ctx, 'forth-proc');
            node.connect(ctx.destination);
            
            node.port.onmessage = (e) => {
                if (e.data.type === 'result') {
                    const r = ed._evalRange;
                    if (r) {
                        ed.setRangeText(e.data.code, r.s, r.e, 'end');
                        node.port.postMessage(ed.value);
                        hl.innerHTML = escapeHtml(ed.value).replace(/\n/g, '<br/>');
                        ed._evalRange = null;
                    }
                } else {
                    renderHighlights(e.data);
                }
            };
            node.port.postMessage(ed.value);
        } catch(e) {
            console.error("AudioWorklet Error:", e);
        }
    }

    document.addEventListener('click', init, {once:true});
    hl.innerHTML = escapeHtml(ed.value).replace(/\n/g, '<br/>');
</script>
</body>
</html>