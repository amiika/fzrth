<!DOCTYPE html>
<head>
    <title>FZRTH</title>
    <style>
        :root { --bg: #000; --fg: #fb0; --hl: #d33; }
        body { background: var(--bg); color: var(--fg); font-family: monospace; margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .header { font-size: 24px; padding: 10px; border-bottom: 1px solid #fb0; text-align: left; background: #111;}
        .container { position: relative; flex: 1; display: flex; }
        #editor { background: transparent; color: transparent; caret-color: #fff; z-index: 2; resize: none; }
        #editor, #highlight { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 20px; font-size: 20px; line-height: 1.5;
            white-space: pre-wrap; word-wrap: break-word;
            box-sizing: border-box; border: none; outline: none; margin: 0;
            font-family: 'Courier New', monospace;
        }
        #highlight { z-index: 1; pointer-events: none; }
        .active { color: #fff; }
    </style>
</head>
<body>
    <div class="header">FZRTH</div>
    <div class="container">
        <div id="highlight"></div>
        <textarea id="editor" spellcheck="false"># Comments & Math Highlighting
<100 200> 50 + sine
[500 1000] rand * saw</textarea>
    </div>

    <template id="template">
        <script id="processor">

        const SUB = 'SUB';
        const CYC = 'CYC';
        const CHO = 'CHO';

        const DICT = {
            'sine': (c) => createSound(c, 'SINE'),
            'tri':  (c) => createSound(c, 'TRI'),
            'saw':  (c) => createSound(c, 'SAW'),
            'sqr':  (c) => createSound(c, 'SQR'),
            'bpm':  (c) => { if (c.stack.length > 0) c.bpm = c.stack.pop().val; },
            '[':    (c) => c.stack.push(SUB),
            ']':    (c) => closeGroup(c, SUB),
            '<':    (c) => c.stack.push(CYC),
            '>':    (c) => closeGroup(c, CYC),
            '(':    (c) => c.stack.push(CHO), 
            ')':    (c) => closeGroup(c, CHO),
            ':':    (c) => defineWord(c),
            'midi': (c) => { c.isMidi = true; },
            '+':    (c, t) => calc(c, t, (a, b) => a + b),
            '-':    (c, t) => calc(c, t, (a, b) => a - b),
            '*':    (c, t) => calc(c, t, (a, b) => a * b),
            '/':    (c, t) => calc(c, t, (a, b) => a / b),
            '%':    (c, t) => calc(c, t, (a, b) => a % b),
            'pow':  (c, t) => calc(c, t, Math.pow),
            'min':  (c, t) => calc(c, t, Math.min),
            'max':  (c, t) => calc(c, t, Math.max),
            'sin':  (c, t) => calc(c, t, Math.sin),
            'cos':  (c, t) => calc(c, t, Math.cos),
            'tan':  (c, t) => calc(c, t, Math.tan),
            'abs':  (c, t) => calc(c, t, Math.abs),
            'sqrt': (c, t) => calc(c, t, Math.sqrt),
            'log':  (c, t) => calc(c, t, Math.log),
            'rand': (c, t) => c.stack.push({ val: Math.random(), ranges: [t] }),
            'pi':   (c, t) => c.stack.push({ val: Math.PI, ranges: [t] }),
        };

        const calc = (c, opToken, fn) => {
            if (c.stack.length < fn.length) return;
            
            const args = [];
            for(let i=0; i<fn.length; i++) args.unshift(c.stack.pop());
            
            const getR = (x) => x.ranges || [x];

            const deep = (a, b) => {
                if (b !== undefined) {
                    if (a.data) return { ...a, data: a.data.map(i => deep(i, b)) };
                    if (b.data) return { ...b, data: b.data.map(i => deep(a, i)) };
                    
                    return { 
                        val: fn(a.val, b.val), 
                        ranges: [opToken, ...getR(a), ...getR(b)]
                    };
                }

                if (a.data) return { ...a, data: a.data.map(i => deep(i)) };
                
                return { 
                    val: fn(a.val), 
                    ranges: [opToken, ...getR(a)]
                };
            };
            
            c.stack.push(deep(args[0], args[1]));
        };

        const WAVES = {
            'SINE': (p) => Math.sin(p * 2 * Math.PI),
            'TRI':  (p) => Math.abs((p % 1) * 4 - 2) - 1,
            'SAW':  (p) => (p % 1) * 2 - 1,
            'SQR':  (p) => (p % 1) < 0.5 ? 0.5 : -0.5
        };

        function defineWord(c) {
            const nameToken = c.tokens[c.pos++];
            const name = nameToken.val;
            const body = [];
            while (c.pos < c.tokens.length) {
                const t = c.tokens[c.pos++];
                if (t.val === ';') break;
                body.push(t);
            }
            c.dict[name] = (ctx) => {
                const savedTokens = ctx.tokens, savedPos = ctx.pos;
                ctx.tokens = body; ctx.pos = 0;
                run(ctx);
                ctx.tokens = savedTokens; ctx.pos = savedPos;
            };
        }

        function run(c) {
            while (c.pos < c.tokens.length) {
                const t = c.tokens[c.pos++];
                const num = parseFloat(t.val);
                if (!isNaN(num)) c.stack.push({ val: num, s: t.s, e: t.e });
                else if (c.dict[t.val]) c.dict[t.val](c, t);
            }
        }

        const midiToFreq = (n) => n === 0 ? 0 : 440 * Math.pow(2, (n - 69) / 12);

        function createSound(c, type) {
            if (c.stack.length === 0) return;

            if (c.isMidi) {
                const convert = (item) => {
                    if (item.val !== undefined) {
                        item.val = midiToFreq(item.val);
                        return item;
                    }
                    if (item.data) {
                        item.data = item.data.map(convert);
                        return item;
                    }
                    return item;
                }
                c.stack = c.stack.map(convert);
                c.isMidi = false; 
            }

            let pattern = c.stack.length > 1 ? { type: SUB, data: [...c.stack] } : c.stack[0];
            c.newSounds.push(new Sound(pattern, type));
            c.stack.length = 0;
        }

        function closeGroup(c, marker) {
            const tmp = [];
            while (c.stack.length > 0) {
                const item = c.stack.pop();
                if (item === marker) {
                    c.stack.push({ type: marker, data: tmp.reverse(), idx: 0 });
                    return;
                }
                tmp.push(item);
            }
        }

        class Sound {
            constructor(pattern, waveType) {
                this.pattern = pattern;
                this.waveType = waveType;
                this.render = WAVES[waveType];
                this.signature = JSON.stringify(pattern, (k, v) => (k==='s'||k==='e'||k==='idx'||k==='ranges') ? undefined : v) + ':' + waveType;
                this.phase = 0;
                this.currFreqs = [];
                this.currRanges = []; 
                this.endTime = -1;
                this.iter = this.makeIterator();
            }

            *makeIterator() { while (true) yield* this.visit(this.pattern, 1.0); }

            *visit(node, duration) {
                const ranges = node.ranges || (node.val !== undefined ? [node] : []);
                
                if (node.val !== undefined) yield { freqs: [node.val], ranges: ranges, dur: duration };
                
                else if (node?.type === CHO) {
                    const data = node.data.flatMap(n => this.collect(n));
                    yield { 
                        freqs: data.map(d => d.val), 
                        ranges: data.flatMap(d => d.ranges || [d]), 
                        dur: duration 
                    };
                }
                else if (node?.type === SUB) {
                    const step = duration / node.data.length;
                    for (const item of node.data) yield* this.visit(item, step);
                } 
                else if (node?.type === CYC) {
                    yield* this.visit(node.data[node.idx++ % node.data.length], duration);
                }
            }

            collect(node) {
                if (node.val !== undefined) return [node];
                if (node?.type === CHO || node?.type === SUB) return node.data.flatMap(n => this.collect(n));
                if (node?.type === CYC) return this.collect(node.data[node.idx % node.data.length]);
                return [];
            }
        }

        class ForthProcessor extends AudioWorkletProcessor {
            constructor() {
                super();
                this.sounds = [];
                this.pending = null; 
                this.bpm = 120;
                this.beats = 0;
                this.port.onmessage = (e) => this.compile(e.data);
            }

            compile(text) {
                const tokens = [];
                const regex = /[^\s\[\]<>() :;]+|[\[\]<>() :;]/g;
                let m;
                while ((m = regex.exec(text)) !== null) {
                    if (!m[0].trim()) continue;
                    if (m[0].startsWith('#')) continue;
                    tokens.push({ val: m[0], s: m.index, e: m.index + m[0].length });
                }

                const ctx = {
                    tokens, pos: 0, stack: [], newSounds: [],
                    dict: Object.assign({}, DICT), bpm: this.bpm
                };

                try { run(ctx); } catch(e) {} 

                if (ctx.stack.length === 0) {
                    this.pending = { sounds: ctx.newSounds, bpm: ctx.bpm };
                }
            }

            process(inputs, outputs) {
                const output = outputs[0][0];
                if (!output) return true;
                const delta = 1 / sampleRate;
                const duration = (this.bpm / 60) * delta;

                if (this.pending) {
                    const nextSounds = this.pending.sounds;
                    const claimed = new Set();
                    nextSounds.forEach(newS => {
                        const match = this.sounds.find(oldS => 
                            oldS.signature === newS.signature && !claimed.has(oldS)
                        );
                        if (match) {
                            claimed.add(match);
                            newS.phase = match.phase;
                        }
                    });
                    this.sounds = nextSounds;
                    this.bpm = this.pending.bpm;
                    this.pending = null;
                }

                let activeRanges = [];

                for (let i = 0; i < output.length; i++) {
                    this.beats += duration;
                    let signal = 0;

                    this.sounds.forEach(v => {
                        if (v.endTime < 0) v.endTime = Math.floor(this.beats);

                        while (this.beats >= v.endTime) {
                            const result = v.iter.next();
                            v.currFreqs = result.value.freqs;
                            v.currRanges = result.value.ranges || [];
                            v.endTime += result.value.dur; 
                        }

                        if (i === 0 && v.currRanges.length > 0) {
                            activeRanges.push(...v.currRanges);
                        }

                        v.currFreqs.forEach(f => {
                            if (f > 0) {
                                v.phase += (f * delta);
                                signal += v.render(v.phase);
                            }
                        });
                    });

                    output[i] = signal * 0.15;
                }

                if (activeRanges.length > 0) {
                    this.port.postMessage(activeRanges);
                }

                return true;
            }
        }
        registerProcessor('forth-proc', ForthProcessor);
        </script>
    </template>

<script>
    const ed = document.getElementById('editor');
    const hl = document.getElementById('highlight');
    let ctx, node;

    function renderHighlights(ranges) {
        const text = ed.value;
        let html = '';
        let lastPos = 0;
        
        const unique = [];
        const map = new Set();
        ranges.forEach(r => {
            const k = r.s + ":" + r.e;
            if(!map.has(k) && r.e > 0) { map.add(k); unique.push(r); }
        });
        unique.sort((a,b) => a.s - b.s);

        unique.forEach(range => {
            html += escapeHtml(text.substring(lastPos, range.s));
            html += `<span class="active">${escapeHtml(text.substring(range.s, range.e))}</span>`;
            lastPos = range.e;
        });
        html += escapeHtml(text.substring(lastPos));
        
        hl.innerHTML = html.replace(/\n/g, '<br/>') + (text.endsWith('\n') ? '<br/>&nbsp;' : '');
    }

    function escapeHtml(str) {
        return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    ed.addEventListener('scroll', () => hl.scrollTop = ed.scrollTop);

    ed.addEventListener('input', () => {
        hl.innerHTML = escapeHtml(ed.value).replace(/\n/g, '<br/>');
        if(node) node.port.postMessage(ed.value); 
    });

    async function init() {
        if (ctx) { 
            ctx.resume(); 
            return; 
        }
        
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        
        const template = document.getElementById('template');
        const code = template.content.getElementById('processor').textContent;
        const blob = new Blob([code], {type: 'application/javascript'});
        await ctx.audioWorklet.addModule(URL.createObjectURL(blob));

        node = new AudioWorkletNode(ctx, 'forth-proc');
        node.connect(ctx.destination);
        
        node.port.onmessage = (e) => {
            renderHighlights(e.data);
        };

        node.port.postMessage(ed.value);
    }

    document.addEventListener('click', init, {once:true});
    
    hl.innerHTML = escapeHtml(ed.value).replace(/\n/g, '<br/>');
</script>
</body>
</html>